package netbase.impl;

import java.io.Serializable;
import netbase.ActivationFunction;


public class Neuron implements Serializable {

  /**
   * Weights associated with this Neuron
   */
  protected Doubles weight;
  /**
   * Bias of the neuron. It should be always 1.0, except for the first layer.
   */
  protected double bias = 1.0;
  /**
   * Inputs of this neuron
   */
  private Doubles input;
  /**
   * Output of this neuron, generated by the activation function.
   */
  private double output;
  /**
   * Value that is passed to the activation function.
   */
  private double outputBeforeActivation;
  /**
   * Number of Inputs. If is 0, it means the neuron wasn't initialized yet.
   */
  private int numberOfInputs = 0;
  /**
   * Activation function of this neuron
   */
  private ActivationFunction activationFunction;


  /**
   * Neuron dummy constructor
   */
  public Neuron() {

  }

  /**
   * Neuron constructor
   *
   * @param numberofinputs Number of Inputs
   */
  public Neuron(int numberofinputs) {
    numberOfInputs = numberofinputs;
    weight = new Doubles(numberofinputs + 1);
    input = new Doubles(numberofinputs);
  }

  /**
   * Neuron constructor
   *
   * @param numberofinputs Number of inputs
   * @param iaf            Activation function
   */
  public Neuron(int numberofinputs, ActivationFunction iaf) {
    numberOfInputs = numberofinputs;
    weight = new Doubles(numberofinputs + 1);
    input = new Doubles(numberofinputs);
    activationFunction = iaf;
  }

  /**
   * init
   * This method initializes the neuron by setting randomly its weights
   */
  public void init(DoubleIterator doubleIterator) {
    if (numberOfInputs > 0) {
      for (int i = 0; i <= numberOfInputs; i++) {
        double newWeight = doubleIterator.nextDouble();
        this.weight.set(i, newWeight);
      }
    }
  }

  /**
   * getArrayInputs
   *
   * @return Returns the neuron's inputs in an ArrayList
   */
  public Doubles getArrayInputs() {
    return input;
  }

  /**
   * getInputs
   *
   * @return Return the neuron's inputs in a vector
   */
  public double[] getInputs() {
    double[] inputs = new double[numberOfInputs];
    for (int i = 0; i < numberOfInputs; i++) {
      inputs[i] = this.input.get(i);
    }
    return inputs;
  }

  /**
   * setInputs
   * Sets a vector of double-precision values to the neuron input
   *
   * @param values vector of values applied at the neuron input
   */
  public void setInputs(double[] values) {
    if (values.length == numberOfInputs) {
      for (int i = 0; i < numberOfInputs; i++) {
        input.set(i, values[i]);
      }
    }
  }

  /**
   * setInputs
   * Sets an array of values to the neuron's input
   *
   * @param values
   */
  public void setInputs(Doubles values) {
    if (values.size() == numberOfInputs) {
      input = values;
    }
  }

  /**
   * setInput
   * Sets a real value at the ith java position of the neuron's inputs
   *
   * @param i     neuron input java index
   * @param value value to be set in the input
   */
  public void setInput(int i, double value) {
    if (i >= 0 && i < numberOfInputs) {
      input.set(i, value);
    }
  }

  /**
   * getInput
   *
   * @param i ith java position at the input
   * @return Returns the ith java input
   */
  public double getInput(int i) {
    return input.get(i);
  }

  /**
   * getWeights
   *
   * @return Returns the neuron's weights in the form of vector
   */
  public double[] getWeights() {
    double[] weights = new double[numberOfInputs + 1];
    for (int i = 0; i <= numberOfInputs; i++) {
      weights[i] = weight.get(i);
    }
    return weights;
  }

  /**
   * getArrayWeights
   *
   * @return Returns the neuron's weights in the form of Arraylist
   */
  public Doubles getArrayWeights() {
    return weight;
  }

  /**
   * updateWeight
   * Method used for updating the weight during learning
   *
   * @param i     ith java position of the weight
   * @param value value to be updated on the weight
   */
  public void updateWeight(int i, double value) {
    if (i >= 0 && i <= numberOfInputs) {
      weight.set(i, value);
    }
  }

  /**
   * getNumberOfInputs
   *
   * @return Returns the number of inputs
   */
  public int getNumberOfInputs() {
    return this.numberOfInputs;
  }

  /**
   * setWeight
   * sets the weight at the ith java position
   *
   * @param i     ith java position
   * @param value value to be set on the weight
   * @throws NeuralException
   */
  public void setWeight(int i, double value) {
    if (i >= 0 && i < numberOfInputs) {
      this.weight.set(i, value);
    } else {
      throw new IndexOutOfBoundsException("Invalid weight index");
    }
  }

  /**
   * getOutput
   *
   * @return Returns the neuron's output
   */
  public double getOutput() {
    return output;
  }

  /**
   * calc
   * Calculates the neuron's output
   */
  public void calc() {
    outputBeforeActivation = 0.0;
    if (numberOfInputs > 0) {
      if (input != null && weight != null) {
        for (int i = 0; i <= numberOfInputs; i++) {
          outputBeforeActivation += (i == numberOfInputs ? bias : input.get(i)) * weight.get(i);
        }
      }
    }
    output = activationFunction.calc(outputBeforeActivation);
  }

  /**
   * setActivationFunction
   * Sets the activation function of this neuron
   *
   * @param iaf Activation function
   */
  public void setActivationFunction(ActivationFunction iaf) {
    this.activationFunction = iaf;
  }

  /**
   * getOutputBeforeActivation
   *
   * @return Returns the weighted sum of the inputs multiplied by weights
   */
  public double getOutputBeforeActivation() {
    return outputBeforeActivation;
  }


}
